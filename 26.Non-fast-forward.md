# Non-fast-forward

В прошлом уроке вы поближе познакомились с состоянием fast-forward. Теперь покажем, что происходит при объединении двух веток, коммиты которых нельзя выстроить в одну цепочку.

## Состояние non-fast-forward

Вернёмся к примеру с ветками main и add-docs и представим такую ситуацию: истории двух веток «разошлись». Это значит, что их коммиты уже нельзя выстроить в одну линию.

Например, после «отделения» add-docs в ветку main добавили новый коммит Commit 5.

```
# команде git log можно указать несколько веток,
# и тогда она выведет их все
$ git log --graph --oneline main add-docs
* 15d3f04 (HEAD -> main) Commit 5
| * 8de42eb (add-docs) New docs 2
| * 4d3c346 New docs 1
|/
* 73def1e Commit 4
* 9c30ab3 Commit 3
* 83cc5ec Commit 2
* 8e87fb2 Commit 1 
```

На схеме это будет выглядеть так.

![](https://pictures.s3.yandex.net/resources/M4_T2_01202_1689343530.png)

Теперь просто «положить» все коммиты из add-docs в main не получится. Например, коммит C5C_5C5? из main может конфликтовать с каким-нибудь коммитом из ветки add-docs (N1N_1N1? или с N2N_2N2?; на схеме ниже мы выбрали N1N_1N1? в качестве примера). То есть содержать изменения в тех же файлах (и в тех же строках), что и коммит C5C_5C5?.

![](https://pictures.s3.yandex.net/resources/M4_T2_02203_1689343586.png)

**?? Когда Git проверяет ветки на состояние fast-forward, он не «заглядывает» в файлы и не пытается угадать, будет ли конфликт на самом деле. Для Git важно только, что конфликт теоретически возможен (или, наоборот, никак не возможен).**

При слиянии не-fast-forward веток Git создаёт коммит слияния.

```
# находимся в ветке main
# --no-edit избавляет от необходимости
# вводить сообщение для merge-коммита
$ git merge --no-edit add-docs
Merge made by the 'ort' strategy.
 docs.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 docs.txt

# коммит слияния: 34f5f8f
$ git log --graph --oneline
*   34f5f8f (HEAD -> main) Merge branch 'add-docs'
|\
| * 8de42eb (add-docs) New docs 2
| * 4d3c346 New docs 1
* | 15d3f04 Commit 5
|/
* 73def1e Commit 4
* 9c30ab3 Commit 3
* 83cc5ec Commit 2
* 8e87fb2 Commit 1 
```

На схеме это будет выглядеть так.

![](https://pictures.s3.yandex.net/resources/M4_T2_03202_1689343628.png)

Если конфликтов при слиянии нет, команда git merge отработает почти автоматически — только предложит вам ввести сообщение для нового коммита слияния.

*?? Чаще всего сообщения к коммитам слияния не редактируют и оставляют «как предложил Git». Для таких случаев удобен флаг --no-edit: git merge --no-edit %another_branch%.*

## Итог:

* Если истории двух веток всё же «разошлись», при слиянии веток Git создаст коммит слияния.

* При объединении веток в состоянии не-fast-forward возможны (но не обязательны) конфликты. Если конфликты всё же возникли, Git попытается разрешить их самостоятельно или попросит вас сделать это вручную.